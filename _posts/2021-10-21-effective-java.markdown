---
layout: post
title:  "[Work in Progress] Effective Java. Конспект"
date:   2021-11-21 15:06:24 +0300
categories: books
---

## Предисловие

Java развивается, становится большим и сложным.
Нужно поддерживать пособие/руководство по лучшим практикам, поэтому
"Effective Java" получила третье издание.
Автор был архитектором платформенных библиотек Java, многих других библиотек,
и он хочет поделиться опытом.

## Глава 1. Введение

Книга содержит 90 пунктов - 90 правил. Каждое правило охватывает практику,
помогающую лучшим программистам. В большинстве поинтов есть примеры кода,
во многих приводятся антипаттерны, объясняется, почему такой код плох,
приводятся альтернативы.\
Эта книга не для начинающих.

Большинство правил основываются на нескольких базовых принципах: понятность
и простота имеют первостепенное значение, поведение компонентов должно быть
предсказуемым (а не удивлять), компоненты должны быть мелкими,
насколько это возможно, но не меньше; код должен переиспользоваться,
а не копироваться; зависимости между компонентами должны быть сведены
к минимуму; ошибки должны быть обнаружены как можно раньше -
в идеале во время компиляции.\
Приведённые в книге правила нацелены на улучшение поддерживаемости кода.

## Глава 2. Создание и удаление объектов

### 1. Используйте статические методы вместо конструкторов
**Потому что**
  - у них есть содержательные имена и можно иметь несколько статических методов
    с разными именами и одинаковыми типами параметров
  - они могут не создавать объект, а, например, брать его из пула
  - они могут возвращать объект любого производного типа
  - можно безопасно изменить класс возвращаемого объекта,
    если интерфейс совпадает
  - класс возвращаемого объекта может не существовать,
    когда мы пишем статический метод

### 2. Попробуйте Builder, если у конструктора много параметров
Когда есть объект с кучей опциональных параметров, он может иметь много
конструкторов, каждый вызывает предыдущий и содержит умолчания для
опциональных параметров.

Можно использовать подход JavaBeans и добавлять все параметры через сеттеры,
но это достаточно многословно и порождает неконсистентное состояние объекта.

В таком случае лучше использовать Builder. Клиентский код будет легко читать,
изменяеть. Этот паттерн костылит именованные параметры со значениями
по умолчанию из других языков.

Проверяйте инварианты в конструкторе билдера и его методах, чтобы узнать
об ошибках как можно раньше. Билдер хорошо сочетается с иерархиями классов -
абстрактные классы будут содержать абстрактные билдеры, а конкретные -
их реализации.

Смотри [Is there a way to refer to the current type with a type variable?][1].

### 3. Обеспечьте синглтон с помощью приватного конструктора или Enum'а
Синглтон - это класс, инстанцируемый только один раз. Обычно он представляет
объект без состояния (процедура) или уникальный по природе компонент.
Синглтоны делают клиентский код сложнотетсируемым.

Приватный конструктор вызывается только один раз - при инициализации
статической переменной. Чтобы защититься от вызова конструктора через рефлексию,
можно выполнить проверку и выбросить исключение в конструкторе.

У статичного метода `SingletonClass.getInstance()` есть ряд преимущств
перед публичной констатой `SingletonClass.INSTANCE`:
  - больше гибкости по управлению жизненным циклом объекта,
    можно поменять логику на несинглтон
  - можно реализовать обобщённую фабрику для синглтонов
  - можно использовать "ссылку" на метод `SingletonClass::getInstance` -
    объект типа `Supplier<SingletonClass>`

Но если никакое из этих преимуществ не используется, то автор предпочитает
публичную статичную константу, потому что это проще.

Чтобы реализовать интерфейс `Serializable` для синглтона, недостаточно
добавить `implements Serializable`. Чтобы гарантировать единственный экземпляр,
нужно объявить все нестатичные атрибуты как `transient` и
определить метод `readResolve`.

```java
public class SingletonClass implements Serializable {
    private final static SingletonClass instance = new SingletonClass();

    private SingletonClass() {}

    private transient String instanceAttribute;

    private Object readResolve() {
        return instance;
    }
}
```

Ещё один способ реализовать синглтон - создать перечисление с одним элементом.
Этот похож на способ с публичным полем, но он более краток, уже включает
механизм сериализации и гарантирует единственный экземпляр даже
при сериализации и использовании рефлексии.

```java
public enum SingletonClass {
    INSTANCE;

    // methods...
}
```

Этот подход может показаться неочевидным, но зачастую это лучший из вариантов.
Однако он неприменим, если нужно унаследоваться от какого-то класса.

### 4. Запрет создания экземпляров с помощью приватного конструктора
Однажды вы захотите написать класс, чтобы сгруппировать связанные статические
методы типа `java.util.Arrays` или `java.util.Math`. Они также могут быть
созданы для группировки статических фабричных методов для создания объектов
с одним интерфейсом типа `java.util.Collections`.

Такие утилитные классы не созданы, чтобы их инстанцировать, но из-за отсутствия
у них конструктора компилятор Java добавляет конструктор по умолчанию.

Попытка запретить инстанцирование класса, делая его абстрактным, не работает,
потому что от него можно наследоваться.

Поэтому нужно использовать приватный конструктор. Можно выбросить из него
исключение, чтобы случайно не вызывать его внутри самого класса.

### 5. Предпочитайте инъекцию зависимостей хардкоду
Много классов зависят от более низкоуровневых ресурсов.
Например, проверщик орфографии (spell checker) зависит от словаря.
Не редкость увидеть реализацию такого класса в виде utility-класса
или синглтона.

```java
public class SpellChecker {
    private static final Lexicon dictionary = ...;

    private SpellChecker() {} // Noninstantiable

    public static boolean isValid(String word) { ... }
    public static List<String> suggestions(String typo) { ... }
}
```

Ни один из этих подходов не является приемлемым, потому что они предполагают
использование только одного словаря. На самом деле, у каждого языка свой
словарь, ещё бы хотелось отдельный словарь для тестирования.

Можно попробовать добавить поддержку множества словарь в `SpellChecker` сделав
поле `dictionary` изменяемым и добавив метод для установки его значения, но
этот код будет неочевиден, склонен к ошибкам и непригодным к использованию в
многопоточной среде. Делать утилитные классы или синглтоны из классов,
поведение которых зависит от других ресурсов, нельзя.

Необходимо обеспечить поддержку множества экземпляров, каждый из которых будет
использовать нужный клиентскому коду ресурс. Простой паттерн - **передавай
ресурс в конструктор при создании экземпляра**.

Этот паттерн, инъекция зависимостей, поддерживает неизменяемость, поэтому
множество клиентов могут пользоваться одним объектом. Инъекция зависимостей
одинаково применима к конструкторам, статическим фабрикам, билдерам.

Полезная вариация этого паттерна - передавать в конструктор фабрику ресурсов.
Фабрика - это объект, к которому можно обращаться повторно для создания
нескольких экземпляров. Такие фабрики реализуют паттерн Фабричный метод.
В Java 8 появился интерфейс `Supplier<T>`, идеально подходящий для фабрик.
Методы, принимающие такие фабрики, должны ограничивать возвращаемые значения
с помощью bounded wildcart type (`Supplier<? extends RequiredService>`), так
клиент сможет передать фабрику любого подтипа RequiredService.

Несмотря на то, что инъекция зависимостей сильно улучшает гибкость и
тестируемость, она может создавать лишний шум в больших проектах. От всего
этого шума можно избавиться используя DI-фреймворк типа Dagger, Guice или
Spring.

В заключение, не используйте utility-классы или синглтоны для реализации
классов, которые от чего-то зависят, и не создавайте эти зависимости напрямую в
ваших классах.  Вместо этого передавайте зависимости (или фабрики для их
создания) через конструктор. Эта практика (инъекция зависимостей) сильно
улучшит гибкость, переиспользуемость и тестируемость вашего класса.

### 6. Избегайте создания лишних объектов
Часто можно переиспользовать объект вместо создания аналогичного каждый раз,
когда он нужен. Переиспользование может быть и быстрее, и лаконичнее.
Если объект неизменяем, его можно переиспользовать всегда.

Часто можно избежать напрасного создания объектов используя статические
фабричные методы вместо конструкторов неизменяемых классов. Например,
`Boolean.valueOf(String)` предпочтительнее, чем конструктор `Boolean(String)`.
Конструктор обязан создавать новый экземпляр, тогда как фабричный метод
не обязан и чаще всего не создаёт новые экземпляры. Можно также
переиспользовать изменяемые объекты, если известно, что они не будут изменены.

Создание некоторых объектов дороже, чем других. Если такой объект требуется
создавать много раз, то рекомендуется его закешировать. Также автор
не рекомендует усложнять получившийся код ленивой (отложенной) инициализацией,
так как часто она не улучшает производительность.

Если объект неизменяем, очевидно, его можно безопасно переиспользовать, но
есть и ситуации, когда это менее очевидно. Рассмотрим паттерн "адаптер".
Так как у адаптера нет состояния, кроме его оригинального объекта, нет
необходимости создавать более одного экземпляра адаптера для одного
оригинального объекта.

Другой пример создания ненужных объектов - автоупаковка, она позволяет мешать
примитивы и объекты. Автоупаковка прячет разницу между примитивами и объектами,
но эта разница никуда не девается. Постоянная упаковка-распаковка сильно
замедляет вашу программу. Поэтому предпочитайте примитивы упакованным объектам,
следите за непреднамеренной автоупаковкой.

Не следует думать, что создать объекты - это дорого и нужно этого избегать.
Наоборот, создание и удаление маленьких объектов с простыми конструкторами -
дёшевые операции, особенно на современных JVM. Создание пулов объектов плохая
идея, если объекты не супер тяжеловесные.

### 7. Уничтожайте устаревшие ссылки



[1]: https://stackoverflow.com/questions/7354740/is-there-a-way-to-refer-to-the-current-type-with-a-type-variable
