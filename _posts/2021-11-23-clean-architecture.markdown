---
layout: post
title:  "[Work in Progress] Чистая архитектура. Конспект"
date:   2021-11-23 13:58:24 +0300
categories: books
---


## Часть III. Принципы дизайна

SOLID определяет, как скомпоновать функции и структуры данных в модули, как они должны сочетаться.

Цель принципов - создать программные структуры среднего уровня, которые:

- терпимы к изменениям
- понятны
- образуют основу компонентов, которые могут использоваться во множестве программных систем

Так как SOLID применим к модулям среднего уровня, он не гарантирует чистоту на других уровнях.

1. SRP (Single Responsibility Principle) - принцип единой ответственности\
  Следствие закона Конвея (Организации проектируют системы, которые копируют структуру коммуникаций в этой организации):\
  Лучшая структура программной системы находится под сильным влиянием социальной структуры организации, которая её использует.
  Поэтому каждый программный модуль должен иметь одну и только одну причину для изменений.

2. OCP (Open-Closed Principle) - принцип открытости/закрытости\
  Чтобы программные системы были легко изменяемыми, они должны быть спроектированы так:
  чтобы поменять их поведение, скорее надо добавить новый код, чем менять существующий.

3. LSP (The Liskov Substitution Principle) - принцип подстановки Лисков\
  Принцип говорит, что чтобы строить системы из взаимозаменяемых компонентов,
  надо, чтобы эти компоненты соответствовали контракту, который позволяет компонентам
  быть взаимозаменяемыми.

4. ISP (Interface Segregation Principle) - принцип разделения интерфейсов\
  Принцип советует избегать неиспользуемых зависимостей.

5. DIP (Dependency Inversion Principle) - принцип инверсии зависимостей\
  Высокоуровневые компоненты не должны зависеть от низкоуровневых реализаций.
  Наоборот, детали должны зависеть от политик (контрактов, абстракций).

Мы сосредоточимся на архитектурных реализациях этих принципов.
Более подробное описание можно посмотреть в

- "Agile Software Development, Principles, Patterns, and Practices" - Robert C. Martin, Prentice Hall, 2002
- Статья Боба Мартина [Принципы Объектно-ориентированного дизайна][1]
- Статья на Википедии [SOLID][2]
- или просто загуглить "SOLID"

Судя по всему книга
"Принципы, паттерны и методики гибкой разработки на языке C#" - Р. С. Мартин, М. Мартин, Символ-Плюс, 2010
является переводом одного из изданий "Agile Software Development, Principles, Patterns, and Practices"

### 7. Принцип единой ответственности

Самый недопонятый принцип, видимо, потому что у него не самое удачное имя.
Программисты, слыша его, думают, что модуль должен делать только одну вещь.
Такой принцип есть, но он относится к более низкоуровневым функциям.

Исторически SRP описан так:
> Модуль должен иметь одну и только одну причину для изменения.

Программные системы изменяются, чтобы удовлетворять пользователей и заказчиков (stakeholders).
Эти пользователи и заказчики и есть "причины для изменения".
Поэтому этот принцип можно перефразировать так:

> Модуль должен быть ответственен за одного и только за одного пользователя или стейкхолдера.

(Под стейкхолдером понимается заинтересованное лицо)

На самом деле говоря "пользователь" или "стейкхолдер" мы имеем в виду группу оных.
Таким образом финальная формулировка SRP выглядит так:

> Модуль должен быть ответственнен за одного и только одного актора (субъект).

Из "Связности" следует принцип единой ответственности.

Пожалуй, лучший способ понять этот принцип - посмотреть признаки его нарушения.

#### Признак 1: случайное дублирование

```java
class Employee {
  void calculatePay() {}
  void reportHours() {}
  void save() {}
}
```

Этот класс нарушает SRP, потому что три его метода ответственны перед тремя разными акторами.

  - метод `calculatePay` установливается бухгалтерией, которая отчитывается финансовому директору
  - `reportHours` установливается и используется отделом кадорв, который отчитывается операционному директору
  - `save` устанавливается администратором БД, который отчитывается техническому директору

__Здесь "устанавливается кем-то" значит "этот кто-то определяет поведение" данного метода__
__Здесь "отчитывается кому-то" значит "этот кто-то и является стейкхолдером" данного метода__

Реализовав эти методы в одном классе, разработчики зацепили (coupling) акторов друг с дргуом.
Изменение требований одного актора может повлиять на что-то, от чего зависят другие акторы.

Если бухгалтерия решит, что нужно поменять алгоритм подсчёта отработанных часов,
то это заденет метод методы calculatePay и reportHours. Однако отдел кадров не хочет,
чтобы метод reportHours менялся, потому что данные об этих часах они используют иначе.

#### Признак 2: конфликты слияния

Файлы с разными методами, отвечающие за разных акторов, склонны к появлению конфликтов слияния.
Слияние конфликтов - довольно рискованное дело.

Избежать этой проблемы можно, разделив код, отвечающий нуждам разным акторам.

#### Решения

Есть много решений этой проблемы - каждое переносит методы в отдельные классы.

Можно сделать из `Employee` DTO и 3 класса: `PayCalculator`, `HoursReporter` и `EmployeeSaver`.\
Можно оставить в `Employee` один важный метод (`save`) и создать 2 класса: `PayCalculator` и `HoursReporter`.

#### Заключение

SRP относится к функциям и классам, но проявляется ещё на двух уровнях:

- на уровне компонентов он становится Common Closure Principle,
- на архитектурном уровне он становится осью изменений (Axis of Change), отвечающей за создание архитектурных границ.

### 8. Принцип открытости/закрытости

Принцип открытости/закрытости был сформулирован Бертраном Мейером в 1988:

> Программный артефакт должен быть открыт для расширения и закрыт для изменения.

Другими словами, программному артефакту следует быть расширяемым без надобности
изменять этот артефакт.\
Принцип открытости/закрытости обретает ещё большее значение на уровне архитектурных компонентов.

#### Мысленный эксперимент

Представим, что нам нужно отобразить финансовый отчёт на веб-странице.
  - Страница должна прокручиваться
  - Отрицательные числа должны быть подсвечены красным цветом.

Теперь представим, что теперь потребовалось печатать отчёт на чёрно-белом принтере.
  - Отчёт должен быть корректно разделён на страницы
  - У отчёта должны быть соответствующие заголовки, колонтитулы и названия столбцов
  - Отрицательные числа должны быть взяты в скобки.

Очевидно, понадобится новый код. Но насколько придётся менять существующий?
Хороший архитектор свёл бы количество изменяемого кода к минимуму, в идеале - к нулю.
Как? Правильно разделяя вещи, меняющиеся по разным причинам (SRP) и организуя зависимости
между ними (DIP).

Здесь важно понять, что создание отчёта включает в себя два аспекта (ответственности):
вычисление данных для отчёта и представление этих данных в одной из двух форм.

Разделив код, нужно убедиться, что изменения в одном аспекте (ответственности)
не влияет на другой.

Более подробное описание смотри в книге.

Важно отметить, что диаграмма зависимостей образует ориентированное дерево
(то есть зависимости компонентов направлены строго в одну сторону).

Если мы хотим, чтобы компонент А был защищён от изменений в компоненте Б,
то Б должен зависеть от А.

А мы хотим защитить контроллер от изменений в презентаторах (presenters).
Мы хотим защитить презентаторы от изменений в представлениях (views).
Мы хотим защитить интекракторы от изменений чего угодно.

Интерактор находится в позиции, которая лучше всего соответствует OCP.
Изменения в базе данных, в контроллере, в презентаторе или в представлении
не окажут влияния на интерактор.

У интерактора такие привилегии, потому что он содержит бизнес-логику,
самые высокоуровневые политики приложения, поэтому он и более защищён.
Контроллер важен менее интерактора, но является центральной частью
для презентатора и представления. Так образуется иерархия защищённости
на основании "уровней".

Так работает принцип открытости/закрытости на уровне архитектуры.
Архитекторы делят функциональность на компоненты по тому, как, почему и когда
они меняются и образуют из них иерархию. Более высокоуровневые компоненты
защищены от изменений в менее высокоуровневых.

#### Заключение

OCP - движущая сила архитектуры систем, его цель - сделать систему
легко расширяемой, уменьшая воздействие изменений.

### 9. Принцип подстановки Лисков

В 1988 Барбара Лисков написала следующее определение подтипов:

> Тут нужно что-то вроде следующего свойства подстановки: Если каждого объекта
  o1 типа S существует объект o2 типа T, такой что для всех программ P,
  определённых в терминах T, поведение P не изменится, когда o2 заменит o1,
  то S - это подтип T.

#### Гайд по наследованию

Положим, есть интерфейс License с методом calcFee, вызываемым приложением
Billing, и две реализации: PersonalLicense и BusinessLicense.
Они используют разные алгоритмы вычисления лицензионного сбора.

Такой дизайн соответствует LSP, потому что приложение Billing не зависит от
используемого подтипа. Обоими подтипами можно заменить тип License.

#### Проблема квадрата/прямоугольника



[1]: http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
[2]: https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)
