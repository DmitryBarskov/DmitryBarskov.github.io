---
layout: post
title:  "[Work in Progress] Чистая архитектура. Конспект"
date:   2021-11-23 13:58:24 +0300
categories: books
---


## Часть III. Принципы дизайна

SOLID определяет, как скомпоновать функции и структуры данных в модули,
как они должны сочетаться.

Цель принципов - создать программные структуры среднего уровня, которые:

- терпимы к изменениям
- понятны
- образуют основу компонентов, которые могут использоваться во множестве
  программных систем

Так как SOLID применим к модулям среднего уровня, он не гарантирует чистоту
на других уровнях.

1. SRP (Single Responsibility Principle) - принцип единой ответственности\
  Следствие закона Конвея (Организации проектируют системы, которые копируют
  структуру коммуникаций в этой организации):\
  Лучшая структура программной системы находится под сильным влиянием
  социальной структуры организации, которая её использует. Поэтому каждый
  программный модуль должен иметь одну и только одну причину для изменений.

2. OCP (Open-Closed Principle) - принцип открытости/закрытости\
  Чтобы программные системы были легко изменяемыми, они должны быть
  спроектированы так: чтобы поменять их поведение, скорее надо добавить
  новый код, чем менять существующий.

3. LSP (The Liskov Substitution Principle) - принцип подстановки Лисков\
  Принцип говорит, что чтобы строить системы из взаимозаменяемых компонентов,
  надо, чтобы эти компоненты соответствовали контракту, который позволяет
  компонентам быть взаимозаменяемыми.

4. ISP (Interface Segregation Principle) - принцип разделения интерфейсов\
  Принцип советует избегать неиспользуемых зависимостей.

5. DIP (Dependency Inversion Principle) - принцип инверсии зависимостей\
  Высокоуровневые компоненты не должны зависеть от низкоуровневых реализаций.
  Наоборот, детали должны зависеть от политик (контрактов, абстракций).

Мы сосредоточимся на архитектурных реализациях этих принципов.
Более подробное описание можно посмотреть в

- "Agile Software Development, Principles, Patterns, and Practices" -
  Robert C. Martin, Prentice Hall, 2002
- Статья Боба Мартина [Принципы Объектно-ориентированного дизайна][1]
- Статья на Википедии [SOLID][2]
- или просто загуглить "SOLID"

Судя по всему книга "Принципы, паттерны и методики гибкой разработки на языке
C#" - Р. С. Мартин, М. Мартин, Символ-Плюс, 2010 является переводом одного из
изданий "Agile Software Development, Principles, Patterns, and Practices"

### 7. Принцип единой ответственности

Самый недопонятый принцип, видимо, потому что у него не самое удачное имя.
Программисты, слыша его, думают, что модуль должен делать только одну вещь.
Такой принцип есть, но он относится к более низкоуровневым функциям.

Исторически SRP описан так:
> Модуль должен иметь одну и только одну причину для изменения.

Программные системы изменяются, чтобы удовлетворять пользователей и заказчиков
(stakeholders). Эти пользователи и заказчики и есть "причины для изменения".
Поэтому этот принцип можно перефразировать так:

> Модуль должен быть ответственен за одного и только за одного пользователя
  или стейкхолдера.

(Под стейкхолдером понимается заинтересованное лицо)

На самом деле говоря "пользователь" или "стейкхолдер" мы имеем в виду группу
оных. Таким образом финальная формулировка SRP выглядит так:

> Модуль должен быть ответственнен за одного и только одного актора (субъект).

Из "Связности" следует принцип единой ответственности.

Пожалуй, лучший способ понять этот принцип - посмотреть признаки его нарушения.

#### Признак 1: случайное дублирование

```java
class Employee {
  void calculatePay() {}
  void reportHours() {}
  void save() {}
}
```

Этот класс нарушает SRP, потому что три его метода ответственны перед
тремя разными акторами.

  - метод `calculatePay` установливается бухгалтерией, которая отчитывается
    финансовому директору
  - `reportHours` установливается и используется отделом кадорв, который
    отчитывается операционному директору
  - `save` устанавливается администратором БД, который отчитывается
    техническому директору

_Здесь "устанавливается кем-то" значит "этот кто-то определяет поведение"
данного метода, "отчитывается кому-то" значит "этот кто-то и
является стейкхолдером" данного метода._

Реализовав эти методы в одном классе, разработчики зацепили (coupling) акторов
друг с дргуом. Изменение требований одного актора может повлиять на что-то,
от чего зависят другие акторы.

Если бухгалтерия решит, что нужно поменять алгоритм подсчёта отработанных часов,
то это заденет метод методы calculatePay и reportHours. Однако отдел кадров
не хочет, чтобы метод reportHours менялся, потому что данные об этих часах
они используют иначе.

#### Признак 2: конфликты слияния

Файлы с разными методами, отвечающие за разных акторов, склонны к появлению
конфликтов слияния. Слияние конфликтов - довольно рискованное дело.

Избежать этой проблемы можно, разделив код, отвечающий нуждам разным акторам.

#### Решения

Есть много решений этой проблемы - каждое переносит методы в отдельные классы.

Можно сделать из `Employee` DTO и 3 класса: `PayCalculator`, `HoursReporter` и
`EmployeeSaver`.\
Можно оставить в `Employee` один важный метод (`save`) и создать 2 класса:
`PayCalculator` и `HoursReporter`.

#### Заключение

SRP относится к функциям и классам, но проявляется ещё на двух уровнях:

- на уровне компонентов он становится Common Closure Principle,
- на архитектурном уровне он становится осью изменений (Axis of Change),
  отвечающей за создание архитектурных границ.

### 8. Принцип открытости/закрытости

Принцип открытости/закрытости был сформулирован Бертраном Мейером в 1988:

> Программный артефакт должен быть открыт для расширения и закрыт для изменения.

Другими словами, программному артефакту следует быть расширяемым без надобности
изменять этот артефакт.\
Принцип открытости/закрытости обретает ещё большее значение на уровне
архитектурных компонентов.

#### Мысленный эксперимент

Представим, что нам нужно отобразить финансовый отчёт на веб-странице.
  - Страница должна прокручиваться
  - Отрицательные числа должны быть подсвечены красным цветом.

Теперь представим, что теперь потребовалось печатать отчёт на чёрно-белом
принтере.
  - Отчёт должен быть корректно разделён на страницы
  - У отчёта должны быть соответствующие заголовки, колонтитулы и названия
    столбцов
  - Отрицательные числа должны быть взяты в скобки.

Очевидно, понадобится новый код. Но насколько придётся менять существующий?
Хороший архитектор свёл бы количество изменяемого кода к минимуму, в идеале -
к нулю. Как? Правильно разделяя код, меняющийся по разным причинам (SRP)
и организуя зависимости между ними (DIP).

Здесь важно понять, что создание отчёта включает в себя два аспекта
(ответственности): вычисление данных для отчёта и представление этих данных
в одной из двух форм.

Разделив код, нужно убедиться, что изменения в одном аспекте (ответственности)
не влияет на другой.

Более подробное описание смотри в книге.

Важно отметить, что диаграмма зависимостей образует ориентированное дерево
(то есть зависимости компонентов направлены строго в одну сторону).

Если мы хотим, чтобы компонент А был защищён от изменений в компоненте Б,
то Б должен зависеть от А.

А мы хотим защитить контроллер от изменений в презентаторах (presenters).
Мы хотим защитить презентаторы от изменений в представлениях (views).
Мы хотим защитить интекракторы от изменений чего угодно.

Интерактор находится в позиции, которая лучше всего соответствует OCP.
Изменения в базе данных, в контроллере, в презентаторе или в представлении
не окажут влияния на интерактор.

У интерактора такие привилегии, потому что он содержит бизнес-логику,
самые высокоуровневые политики приложения, поэтому он и более защищён.
Контроллер важен менее интерактора, но является центральной частью
для презентатора и представления. Так образуется иерархия защищённости
на основании "уровней".

Так работает принцип открытости/закрытости на уровне архитектуры.
Архитекторы делят функциональность на компоненты по тому, как, почему и когда
они меняются и образуют из них иерархию. Более высокоуровневые компоненты
защищены от изменений в менее высокоуровневых.

#### Заключение

OCP - движущая сила архитектуры систем, его цель - сделать систему
легко расширяемой, уменьшая воздействие изменений.

### 9. Принцип подстановки Лисков

В 1988 Барбара Лисков написала следующее определение подтипов:

> Тут нужно что-то вроде следующего свойства подстановки: Если каждого объекта
  o1 типа S существует объект o2 типа T, такой что для всех программ P,
  определённых в терминах T, поведение P не изменится, когда o2 заменит o1,
  то S - это подтип T.

#### Гайд по наследованию

Положим, есть интерфейс License с методом calcFee, вызываемым приложением
Billing, и две реализации: PersonalLicense и BusinessLicense.
Они используют разные алгоритмы вычисления лицензионного сбора.

Такой дизайн соответствует LSP, потому что приложение Billing не зависит от
используемого подтипа. Обоими подтипами можно заменить тип License.

#### Проблема квадрата/прямоугольника

В этой проблеме демонстрируется нарушение LSP.

У класса Rectangle есть два метода: setH и setW. Класс Square наследуется
от него и добавляет метод setSize.

В этом примере Sqaure невалидный подтип Rectangle, потому что высота и ширина
Rectangle могут меняться независимо. Напротив, высота и ширина Square должны
меняться вместе.

```java
Rectangle r = new Rectangle();
r.setW(5);
r.setH(2);
assert r.area() == 10;
```

Если `new Rectangle()` заменить на `new Square()`, то клиентский код сломается.
Поэтому типы не взаимозаменяемы.

#### LSP и архитектура

Под интерфейсом понимается больше, чем тип в Java. Это может быть набор
сервисов, отвечающих одному REST интерфейсу.
В подобных ситуациях применим LSP, потому что есть клиент, зависящий от
чётко определённого интерфейсов и от взаимозаменяемых реализаций этих
интерфейсов.

#### Пример нарушения LSP

Мы создаём агрегатор такси. Клиенты будут пользоваться нашим сайтом, чтобы
найти наиболее подходящее такси независимо от служб такси. Когда клиент
выбирает такси, наша система заказывает такси, используя REST сервис.

Ожидаются, что для всех компаний можно заказать такси используя один формат
запросов (например,
`PUT /driver/Bob/pickupAddress/24 Maple St./pickupTime/153/destination/ORD`).

Предположим, что нашлась компания Acme, которая не хочет следовать
этому формату. Нужно добавить обработку этого специального случая, самый
простой путь: `if (driver.getDispatchUri().startWith("acme.com")) { ... }`

Но, разумеется, ни один архитектор такого не допустит. Вместо этого архитектор
решил предупредить возможные баги и точки для расширения приложения и создать
модуль для создания команд диспетчеризации, хранящий данные в базе типа
ключ-значение, где ключ это URI, а значение - формат запроса:

```csv
URI, Dispatch Format
Acme.com, /pickupAddress/%s/pickupTime/%s/dest/%s
*.*, /pickupAddress/%s/pickupTime/%s/destination/%s
```

Таким образом, архитектору пришлось значительно усложнить систему из-за того,
что не все интерфейсы оказались совместимыми.

#### Заключение

LSP должен быть расширен до уровня архитектуры. Нарушение этого принципа
приводит к загрязнению архитектуры значительным количеством дополнительных
механизмов.

### 10. Принцип разделения интерфейсов

Положим у нас есть класс `Ops` с методами `op1`, `op2` и `op3`. И есть три
класса: `User1`, который использует только метод `op1` класса `Ops`,
`User2`, использующий только `op2`, и `User3`, использующий только `op3`.

Если мы поменяем метод `op2`, то всё равно придётся пересобрать и
передеплоить класс `User1` в языках типа Java.

Эту проблему можно решить, добавив три интерфейса: `U1Ops`, `U2Ops` и `U3Ops`,
содержащие объявления методов `op1`, `op2` и `op3` соответственно, заставить
`User1`, `User2` и `User3` зависеть от этих интерфейсов и добавить поддержку
интерфейсов в класс `Ops`.

#### ISP и язык программирования

Очевидно, предыдущее описание зависит от языка программирования. Это может
заставить вас подумать, что ISP это скорее проблема определённых языков.

#### ISP и архитектура

В общем случае, вредно быть в зависимости от модулей, которые содержат больше,
чем нужно вам. Очевидно, что это верно для зависимостей в исходном коде, но это
так же верно и на более высоком, архитектурном, уровне.

Если есть система S, зависящее от фреймворка F, который в свою очередь зависит
от базы данных D, и F использует только часть возможностей D,
то изменения в неиспользуемых возможностях D, могут заставить вас редеплоить F
и S. Хуже того, ошибка в неиспользуемых функциях D, могут сломать и фреймворк,
и вашу систему.

#### Заключение

Зависимость от вещей, которые вы не используете, создаёт проблемы, которые вы
не ожидаете.

### 11. Принцип инверсии зависимости

DIP гласит, что в гибких системах исходных код ссылается только на абстракции,
а не на реализации.

Исключением могут быть конкретные реализации в стандартный библиотеках,
потому что они очень стабильны (не меняются).

Мы должны избегать зависимостей от изменчивых конкретных элементов
нашей системы. Это модули, которые мы активно разрабатываем.

#### Надёжные абстракции

Каждое изменение в интерфейсе требует изменения всех его реализаций. И наоборот,
изменения в реализациях редко требуют изменений в интерфейсах. То есть
интерфейсы менее изменчивы, чем реализации.

Архитекторы стараются уменьшить волатильность интерфейсов, добавлять
функциональность в реализации, не меняя интерфейсы. Стабильные архитектуры
избегают зависимостей от изменчивых реализаций. Из этого следуют следующие
практики:
  - не ссылайтесь на изменчивые конкретные классы, ссылайтесь на абстрактные
    интерфейсы
  - не наследуйтесь от изменчивых конкретных классов
  - не переопределяйте конкретные методы. Конкретные методы зависят от кода
    вокруг, поэтому когда вы переопределяете эти методы, вы не избавляетесь от
    их зависимостей, вы наследуете их. Чтобы такого не происходило, нужно
    сделать переопределяемый метод абстрактным и создать множество реализаций
  - никогда не упомянайте имена чего-то конкретного и изменчивого

#### Фабрики

Чтобы следовать этим правилам, необходимо особым образом обрабатывать создание
конкретных изменчивых объектов. Это так, потому что во всех языках создание
объекта требует прямую зависимость на конкретное определение этого объекта.

В большинстве ОО языков следует использовать паттерн "Абстрактная фабрика"
для управления этими нежелательными зависимостями.

На схеме "Абстрактной фабрики" можно провести черту между абстрактными и
конкретными компонентами (это архитектурная граница). Стрелки зависимости
пересекают эту черту строго в одном направлении, противоположном потоку
управления (я так понял, интерфейс "упарвляет" реализациями, потому что меняя
интерфейс, нам нужно менять реализацию, но не наоборот). Поэтому принцип
и называется - принцип инверсии зависимости.

#### Конкретные компоненты

Большинство систем будут содержать компонент, который зависит от многих
конкретных реализаций и нарушает DIP, часто называющийся main.

#### Заключение

Это самый важный организационный принцип в проектировании архитектуры.

[1]: http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
[2]: https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)
